#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Feb 10 15:08:45 2018 by generateDS.py version 2.29.5.
# Python 3.6.4 | packaged by conda-forge | (default, Dec 23 2017, 16:54:01)  [GCC 4.2.1 Compatible Apple LLVM 6.1.0 (clang-602.0.53)]
#
# Command line options:
#   ('-o', 'EAF.py')
#
# Command line arguments:
#   EAFv2.8.xsd
#
# Command line:
#   /Users/paul/anaconda/bin/generateDS.py -o "EAF.py" EAFv2.8.xsd
#
# Current working directory (os.getcwd()):
#   testData
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ANNOTATION_DOCUMENT(GeneratedsSuper):
    """The Tier name/id should be unique within the collection of Tier
    elements A Tier can be associated with a parent Tier by
    referring to an existing Tier id. The Linguistic Type name/id
    should be unique within the collection of Linguistic Type
    elements A Tier must refer to an existing Linguistic Type id.
    The Controlled Vocabulary name/id should be unique within the
    collection of Controlled Vocabulary elements A Linguistic Type
    can be associated with a Controlled Vocabulary by referring to
    an existing Controlled Vocabulary id. The Lexicon Service
    name/id should be unique within the collection of Lexicon
    Service elements A Linguistic Type can be associated with a
    Lexicon Service by referring to an existing Lexicon Service id.
    A key and keyref pair to enforce that a previous annotation
    idref at least refers to an annotation id of a reference
    annotation. Two key-keyref pairs to enforce that time slot
    references refer to the id of a time slot. The ID of a language
    identifier, can be referred to by any element that needs a
    reference to a language identifier. Reference from a value in a
    multilingual CV to a language identifier. Reference from a
    description in a multilingual CV to a language identifier.
    Reference from a tier to a language identifier, to indicate the
    (main) language recorded on that tier. Reference from an
    individual alignable annotation to a language identifier.
    Reference from an individual reference annotation to a language
    identifier."""
    subclass = None
    superclass = None
    def __init__(self, DATE=None, AUTHOR=None, VERSION=None, FORMAT='2.8', LICENSE=None, HEADER=None, TIME_ORDER=None, TIER=None, LINGUISTIC_TYPE=None, LOCALE=None, LANGUAGE=None, CONSTRAINT=None, CONTROLLED_VOCABULARY=None, LEXICON_REF=None, EXTERNAL_REF=None):
        self.original_tagname_ = None
        if isinstance(DATE, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DATE, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DATE
        self.DATE = initvalue_
        self.AUTHOR = _cast(None, AUTHOR)
        self.VERSION = _cast(None, VERSION)
        self.FORMAT = _cast(None, FORMAT)
        if LICENSE is None:
            self.LICENSE = []
        else:
            self.LICENSE = LICENSE
        self.HEADER = HEADER
        self.TIME_ORDER = TIME_ORDER
        if TIER is None:
            self.TIER = []
        else:
            self.TIER = TIER
        if LINGUISTIC_TYPE is None:
            self.LINGUISTIC_TYPE = []
        else:
            self.LINGUISTIC_TYPE = LINGUISTIC_TYPE
        if LOCALE is None:
            self.LOCALE = []
        else:
            self.LOCALE = LOCALE
        if LANGUAGE is None:
            self.LANGUAGE = []
        else:
            self.LANGUAGE = LANGUAGE
        if CONSTRAINT is None:
            self.CONSTRAINT = []
        else:
            self.CONSTRAINT = CONSTRAINT
        if CONTROLLED_VOCABULARY is None:
            self.CONTROLLED_VOCABULARY = []
        else:
            self.CONTROLLED_VOCABULARY = CONTROLLED_VOCABULARY
        if LEXICON_REF is None:
            self.LEXICON_REF = []
        else:
            self.LEXICON_REF = LEXICON_REF
        if EXTERNAL_REF is None:
            self.EXTERNAL_REF = []
        else:
            self.EXTERNAL_REF = EXTERNAL_REF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANNOTATION_DOCUMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANNOTATION_DOCUMENT.subclass:
            return ANNOTATION_DOCUMENT.subclass(*args_, **kwargs_)
        else:
            return ANNOTATION_DOCUMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LICENSE(self): return self.LICENSE
    def set_LICENSE(self, LICENSE): self.LICENSE = LICENSE
    def add_LICENSE(self, value): self.LICENSE.append(value)
    def insert_LICENSE_at(self, index, value): self.LICENSE.insert(index, value)
    def replace_LICENSE_at(self, index, value): self.LICENSE[index] = value
    def get_HEADER(self): return self.HEADER
    def set_HEADER(self, HEADER): self.HEADER = HEADER
    def get_TIME_ORDER(self): return self.TIME_ORDER
    def set_TIME_ORDER(self, TIME_ORDER): self.TIME_ORDER = TIME_ORDER
    def get_TIER(self): return self.TIER
    def set_TIER(self, TIER): self.TIER = TIER
    def add_TIER(self, value): self.TIER.append(value)
    def insert_TIER_at(self, index, value): self.TIER.insert(index, value)
    def replace_TIER_at(self, index, value): self.TIER[index] = value
    def get_LINGUISTIC_TYPE(self): return self.LINGUISTIC_TYPE
    def set_LINGUISTIC_TYPE(self, LINGUISTIC_TYPE): self.LINGUISTIC_TYPE = LINGUISTIC_TYPE
    def add_LINGUISTIC_TYPE(self, value): self.LINGUISTIC_TYPE.append(value)
    def insert_LINGUISTIC_TYPE_at(self, index, value): self.LINGUISTIC_TYPE.insert(index, value)
    def replace_LINGUISTIC_TYPE_at(self, index, value): self.LINGUISTIC_TYPE[index] = value
    def get_LOCALE(self): return self.LOCALE
    def set_LOCALE(self, LOCALE): self.LOCALE = LOCALE
    def add_LOCALE(self, value): self.LOCALE.append(value)
    def insert_LOCALE_at(self, index, value): self.LOCALE.insert(index, value)
    def replace_LOCALE_at(self, index, value): self.LOCALE[index] = value
    def get_LANGUAGE(self): return self.LANGUAGE
    def set_LANGUAGE(self, LANGUAGE): self.LANGUAGE = LANGUAGE
    def add_LANGUAGE(self, value): self.LANGUAGE.append(value)
    def insert_LANGUAGE_at(self, index, value): self.LANGUAGE.insert(index, value)
    def replace_LANGUAGE_at(self, index, value): self.LANGUAGE[index] = value
    def get_CONSTRAINT(self): return self.CONSTRAINT
    def set_CONSTRAINT(self, CONSTRAINT): self.CONSTRAINT = CONSTRAINT
    def add_CONSTRAINT(self, value): self.CONSTRAINT.append(value)
    def insert_CONSTRAINT_at(self, index, value): self.CONSTRAINT.insert(index, value)
    def replace_CONSTRAINT_at(self, index, value): self.CONSTRAINT[index] = value
    def get_CONTROLLED_VOCABULARY(self): return self.CONTROLLED_VOCABULARY
    def set_CONTROLLED_VOCABULARY(self, CONTROLLED_VOCABULARY): self.CONTROLLED_VOCABULARY = CONTROLLED_VOCABULARY
    def add_CONTROLLED_VOCABULARY(self, value): self.CONTROLLED_VOCABULARY.append(value)
    def insert_CONTROLLED_VOCABULARY_at(self, index, value): self.CONTROLLED_VOCABULARY.insert(index, value)
    def replace_CONTROLLED_VOCABULARY_at(self, index, value): self.CONTROLLED_VOCABULARY[index] = value
    def get_LEXICON_REF(self): return self.LEXICON_REF
    def set_LEXICON_REF(self, LEXICON_REF): self.LEXICON_REF = LEXICON_REF
    def add_LEXICON_REF(self, value): self.LEXICON_REF.append(value)
    def insert_LEXICON_REF_at(self, index, value): self.LEXICON_REF.insert(index, value)
    def replace_LEXICON_REF_at(self, index, value): self.LEXICON_REF[index] = value
    def get_EXTERNAL_REF(self): return self.EXTERNAL_REF
    def set_EXTERNAL_REF(self, EXTERNAL_REF): self.EXTERNAL_REF = EXTERNAL_REF
    def add_EXTERNAL_REF(self, value): self.EXTERNAL_REF.append(value)
    def insert_EXTERNAL_REF_at(self, index, value): self.EXTERNAL_REF.insert(index, value)
    def replace_EXTERNAL_REF_at(self, index, value): self.EXTERNAL_REF[index] = value
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_AUTHOR(self): return self.AUTHOR
    def set_AUTHOR(self, AUTHOR): self.AUTHOR = AUTHOR
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def get_FORMAT(self): return self.FORMAT
    def set_FORMAT(self, FORMAT): self.FORMAT = FORMAT
    def hasContent_(self):
        if (
            self.LICENSE or
            self.HEADER is not None or
            self.TIME_ORDER is not None or
            self.TIER or
            self.LINGUISTIC_TYPE or
            self.LOCALE or
            self.LANGUAGE or
            self.CONSTRAINT or
            self.CONTROLLED_VOCABULARY or
            self.LEXICON_REF or
            self.EXTERNAL_REF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ANNOTATION_DOCUMENT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANNOTATION_DOCUMENT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ANNOTATION_DOCUMENT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ANNOTATION_DOCUMENT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ANNOTATION_DOCUMENT'):
        if self.DATE is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            outfile.write(' DATE="%s"' % self.gds_format_datetime(self.DATE, input_name='DATE'))
        if self.AUTHOR is not None and 'AUTHOR' not in already_processed:
            already_processed.add('AUTHOR')
            outfile.write(' AUTHOR=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.AUTHOR), input_name='AUTHOR')), ))
        if self.VERSION is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            outfile.write(' VERSION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.VERSION), input_name='VERSION')), ))
        if self.FORMAT != "2.8" and 'FORMAT' not in already_processed:
            already_processed.add('FORMAT')
            outfile.write(' FORMAT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FORMAT), input_name='FORMAT')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ANNOTATION_DOCUMENT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LICENSE_ in self.LICENSE:
            LICENSE_.export(outfile, level, namespace_, name_='LICENSE', pretty_print=pretty_print)
        if self.HEADER is not None:
            self.HEADER.export(outfile, level, namespace_, name_='HEADER', pretty_print=pretty_print)
        if self.TIME_ORDER is not None:
            self.TIME_ORDER.export(outfile, level, namespace_, name_='TIME_ORDER', pretty_print=pretty_print)
        for TIER_ in self.TIER:
            TIER_.export(outfile, level, namespace_, name_='TIER', pretty_print=pretty_print)
        for LINGUISTIC_TYPE_ in self.LINGUISTIC_TYPE:
            LINGUISTIC_TYPE_.export(outfile, level, namespace_, name_='LINGUISTIC_TYPE', pretty_print=pretty_print)
        for LOCALE_ in self.LOCALE:
            LOCALE_.export(outfile, level, namespace_, name_='LOCALE', pretty_print=pretty_print)
        for LANGUAGE_ in self.LANGUAGE:
            LANGUAGE_.export(outfile, level, namespace_, name_='LANGUAGE', pretty_print=pretty_print)
        for CONSTRAINT_ in self.CONSTRAINT:
            CONSTRAINT_.export(outfile, level, namespace_, name_='CONSTRAINT', pretty_print=pretty_print)
        for CONTROLLED_VOCABULARY_ in self.CONTROLLED_VOCABULARY:
            CONTROLLED_VOCABULARY_.export(outfile, level, namespace_, name_='CONTROLLED_VOCABULARY', pretty_print=pretty_print)
        for LEXICON_REF_ in self.LEXICON_REF:
            LEXICON_REF_.export(outfile, level, namespace_, name_='LEXICON_REF', pretty_print=pretty_print)
        for EXTERNAL_REF_ in self.EXTERNAL_REF:
            EXTERNAL_REF_.export(outfile, level, namespace_, name_='EXTERNAL_REF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DATE', node)
        if value is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            try:
                self.DATE = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DATE): %s' % exp)
        value = find_attr_value_('AUTHOR', node)
        if value is not None and 'AUTHOR' not in already_processed:
            already_processed.add('AUTHOR')
            self.AUTHOR = value
        value = find_attr_value_('VERSION', node)
        if value is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            self.VERSION = value
        value = find_attr_value_('FORMAT', node)
        if value is not None and 'FORMAT' not in already_processed:
            already_processed.add('FORMAT')
            self.FORMAT = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LICENSE':
            obj_ = licenseType.factory()
            obj_.build(child_)
            self.LICENSE.append(obj_)
            obj_.original_tagname_ = 'LICENSE'
        elif nodeName_ == 'HEADER':
            obj_ = headType.factory()
            obj_.build(child_)
            self.HEADER = obj_
            obj_.original_tagname_ = 'HEADER'
        elif nodeName_ == 'TIME_ORDER':
            obj_ = timeType.factory()
            obj_.build(child_)
            self.TIME_ORDER = obj_
            obj_.original_tagname_ = 'TIME_ORDER'
        elif nodeName_ == 'TIER':
            obj_ = tierType.factory()
            obj_.build(child_)
            self.TIER.append(obj_)
            obj_.original_tagname_ = 'TIER'
        elif nodeName_ == 'LINGUISTIC_TYPE':
            obj_ = lingType.factory()
            obj_.build(child_)
            self.LINGUISTIC_TYPE.append(obj_)
            obj_.original_tagname_ = 'LINGUISTIC_TYPE'
        elif nodeName_ == 'LOCALE':
            obj_ = localeType.factory()
            obj_.build(child_)
            self.LOCALE.append(obj_)
            obj_.original_tagname_ = 'LOCALE'
        elif nodeName_ == 'LANGUAGE':
            obj_ = langType.factory()
            obj_.build(child_)
            self.LANGUAGE.append(obj_)
            obj_.original_tagname_ = 'LANGUAGE'
        elif nodeName_ == 'CONSTRAINT':
            obj_ = constraintType.factory()
            obj_.build(child_)
            self.CONSTRAINT.append(obj_)
            obj_.original_tagname_ = 'CONSTRAINT'
        elif nodeName_ == 'CONTROLLED_VOCABULARY':
            obj_ = convocType.factory()
            obj_.build(child_)
            self.CONTROLLED_VOCABULARY.append(obj_)
            obj_.original_tagname_ = 'CONTROLLED_VOCABULARY'
        elif nodeName_ == 'LEXICON_REF':
            obj_ = lexRefType.factory()
            obj_.build(child_)
            self.LEXICON_REF.append(obj_)
            obj_.original_tagname_ = 'LEXICON_REF'
        elif nodeName_ == 'EXTERNAL_REF':
            obj_ = extRefType.factory()
            obj_.build(child_)
            self.EXTERNAL_REF.append(obj_)
            obj_.original_tagname_ = 'EXTERNAL_REF'
# end class ANNOTATION_DOCUMENT


class headType(GeneratedsSuper):
    """This attribute is deprecated. Use MEDIA_DESCRIPTOR elements instead."""
    subclass = None
    superclass = None
    def __init__(self, MEDIA_FILE=None, TIME_UNITS='milliseconds', MEDIA_DESCRIPTOR=None, LINKED_FILE_DESCRIPTOR=None, PROPERTY=None):
        self.original_tagname_ = None
        self.MEDIA_FILE = _cast(None, MEDIA_FILE)
        self.TIME_UNITS = _cast(None, TIME_UNITS)
        if MEDIA_DESCRIPTOR is None:
            self.MEDIA_DESCRIPTOR = []
        else:
            self.MEDIA_DESCRIPTOR = MEDIA_DESCRIPTOR
        if LINKED_FILE_DESCRIPTOR is None:
            self.LINKED_FILE_DESCRIPTOR = []
        else:
            self.LINKED_FILE_DESCRIPTOR = LINKED_FILE_DESCRIPTOR
        if PROPERTY is None:
            self.PROPERTY = []
        else:
            self.PROPERTY = PROPERTY
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, headType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if headType.subclass:
            return headType.subclass(*args_, **kwargs_)
        else:
            return headType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MEDIA_DESCRIPTOR(self): return self.MEDIA_DESCRIPTOR
    def set_MEDIA_DESCRIPTOR(self, MEDIA_DESCRIPTOR): self.MEDIA_DESCRIPTOR = MEDIA_DESCRIPTOR
    def add_MEDIA_DESCRIPTOR(self, value): self.MEDIA_DESCRIPTOR.append(value)
    def insert_MEDIA_DESCRIPTOR_at(self, index, value): self.MEDIA_DESCRIPTOR.insert(index, value)
    def replace_MEDIA_DESCRIPTOR_at(self, index, value): self.MEDIA_DESCRIPTOR[index] = value
    def get_LINKED_FILE_DESCRIPTOR(self): return self.LINKED_FILE_DESCRIPTOR
    def set_LINKED_FILE_DESCRIPTOR(self, LINKED_FILE_DESCRIPTOR): self.LINKED_FILE_DESCRIPTOR = LINKED_FILE_DESCRIPTOR
    def add_LINKED_FILE_DESCRIPTOR(self, value): self.LINKED_FILE_DESCRIPTOR.append(value)
    def insert_LINKED_FILE_DESCRIPTOR_at(self, index, value): self.LINKED_FILE_DESCRIPTOR.insert(index, value)
    def replace_LINKED_FILE_DESCRIPTOR_at(self, index, value): self.LINKED_FILE_DESCRIPTOR[index] = value
    def get_PROPERTY(self): return self.PROPERTY
    def set_PROPERTY(self, PROPERTY): self.PROPERTY = PROPERTY
    def add_PROPERTY(self, value): self.PROPERTY.append(value)
    def insert_PROPERTY_at(self, index, value): self.PROPERTY.insert(index, value)
    def replace_PROPERTY_at(self, index, value): self.PROPERTY[index] = value
    def get_MEDIA_FILE(self): return self.MEDIA_FILE
    def set_MEDIA_FILE(self, MEDIA_FILE): self.MEDIA_FILE = MEDIA_FILE
    def get_TIME_UNITS(self): return self.TIME_UNITS
    def set_TIME_UNITS(self, TIME_UNITS): self.TIME_UNITS = TIME_UNITS
    def hasContent_(self):
        if (
            self.MEDIA_DESCRIPTOR or
            self.LINKED_FILE_DESCRIPTOR or
            self.PROPERTY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='headType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('headType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='headType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='headType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='headType'):
        if self.MEDIA_FILE is not None and 'MEDIA_FILE' not in already_processed:
            already_processed.add('MEDIA_FILE')
            outfile.write(' MEDIA_FILE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MEDIA_FILE), input_name='MEDIA_FILE')), ))
        if self.TIME_UNITS != "milliseconds" and 'TIME_UNITS' not in already_processed:
            already_processed.add('TIME_UNITS')
            outfile.write(' TIME_UNITS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TIME_UNITS), input_name='TIME_UNITS')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='headType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MEDIA_DESCRIPTOR_ in self.MEDIA_DESCRIPTOR:
            MEDIA_DESCRIPTOR_.export(outfile, level, namespace_, name_='MEDIA_DESCRIPTOR', pretty_print=pretty_print)
        for LINKED_FILE_DESCRIPTOR_ in self.LINKED_FILE_DESCRIPTOR:
            LINKED_FILE_DESCRIPTOR_.export(outfile, level, namespace_, name_='LINKED_FILE_DESCRIPTOR', pretty_print=pretty_print)
        for PROPERTY_ in self.PROPERTY:
            PROPERTY_.export(outfile, level, namespace_, name_='PROPERTY', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MEDIA_FILE', node)
        if value is not None and 'MEDIA_FILE' not in already_processed:
            already_processed.add('MEDIA_FILE')
            self.MEDIA_FILE = value
        value = find_attr_value_('TIME_UNITS', node)
        if value is not None and 'TIME_UNITS' not in already_processed:
            already_processed.add('TIME_UNITS')
            self.TIME_UNITS = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MEDIA_DESCRIPTOR':
            obj_ = MEDIA_DESCRIPTORType.factory()
            obj_.build(child_)
            self.MEDIA_DESCRIPTOR.append(obj_)
            obj_.original_tagname_ = 'MEDIA_DESCRIPTOR'
        elif nodeName_ == 'LINKED_FILE_DESCRIPTOR':
            obj_ = LINKED_FILE_DESCRIPTORType.factory()
            obj_.build(child_)
            self.LINKED_FILE_DESCRIPTOR.append(obj_)
            obj_.original_tagname_ = 'LINKED_FILE_DESCRIPTOR'
        elif nodeName_ == 'PROPERTY':
            obj_ = propType.factory()
            obj_.build(child_)
            self.PROPERTY.append(obj_)
            obj_.original_tagname_ = 'PROPERTY'
# end class headType


class timeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TIME_SLOT=None):
        self.original_tagname_ = None
        if TIME_SLOT is None:
            self.TIME_SLOT = []
        else:
            self.TIME_SLOT = TIME_SLOT
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timeType.subclass:
            return timeType.subclass(*args_, **kwargs_)
        else:
            return timeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TIME_SLOT(self): return self.TIME_SLOT
    def set_TIME_SLOT(self, TIME_SLOT): self.TIME_SLOT = TIME_SLOT
    def add_TIME_SLOT(self, value): self.TIME_SLOT.append(value)
    def insert_TIME_SLOT_at(self, index, value): self.TIME_SLOT.insert(index, value)
    def replace_TIME_SLOT_at(self, index, value): self.TIME_SLOT[index] = value
    def hasContent_(self):
        if (
            self.TIME_SLOT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='timeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('timeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='timeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='timeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='timeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='timeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TIME_SLOT_ in self.TIME_SLOT:
            TIME_SLOT_.export(outfile, level, namespace_, name_='TIME_SLOT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TIME_SLOT':
            obj_ = TIME_SLOTType.factory()
            obj_.build(child_)
            self.TIME_SLOT.append(obj_)
            obj_.original_tagname_ = 'TIME_SLOT'
# end class timeType


class tierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TIER_ID=None, PARTICIPANT=None, ANNOTATOR=None, LINGUISTIC_TYPE_REF=None, DEFAULT_LOCALE=None, PARENT_REF=None, EXT_REF=None, LANG_REF=None, ANNOTATION=None):
        self.original_tagname_ = None
        self.TIER_ID = _cast(None, TIER_ID)
        self.PARTICIPANT = _cast(None, PARTICIPANT)
        self.ANNOTATOR = _cast(None, ANNOTATOR)
        self.LINGUISTIC_TYPE_REF = _cast(None, LINGUISTIC_TYPE_REF)
        self.DEFAULT_LOCALE = _cast(None, DEFAULT_LOCALE)
        self.PARENT_REF = _cast(None, PARENT_REF)
        self.EXT_REF = _cast(None, EXT_REF)
        self.LANG_REF = _cast(None, LANG_REF)
        if ANNOTATION is None:
            self.ANNOTATION = []
        else:
            self.ANNOTATION = ANNOTATION
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tierType.subclass:
            return tierType.subclass(*args_, **kwargs_)
        else:
            return tierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ANNOTATION(self): return self.ANNOTATION
    def set_ANNOTATION(self, ANNOTATION): self.ANNOTATION = ANNOTATION
    def add_ANNOTATION(self, value): self.ANNOTATION.append(value)
    def insert_ANNOTATION_at(self, index, value): self.ANNOTATION.insert(index, value)
    def replace_ANNOTATION_at(self, index, value): self.ANNOTATION[index] = value
    def get_TIER_ID(self): return self.TIER_ID
    def set_TIER_ID(self, TIER_ID): self.TIER_ID = TIER_ID
    def get_PARTICIPANT(self): return self.PARTICIPANT
    def set_PARTICIPANT(self, PARTICIPANT): self.PARTICIPANT = PARTICIPANT
    def get_ANNOTATOR(self): return self.ANNOTATOR
    def set_ANNOTATOR(self, ANNOTATOR): self.ANNOTATOR = ANNOTATOR
    def get_LINGUISTIC_TYPE_REF(self): return self.LINGUISTIC_TYPE_REF
    def set_LINGUISTIC_TYPE_REF(self, LINGUISTIC_TYPE_REF): self.LINGUISTIC_TYPE_REF = LINGUISTIC_TYPE_REF
    def get_DEFAULT_LOCALE(self): return self.DEFAULT_LOCALE
    def set_DEFAULT_LOCALE(self, DEFAULT_LOCALE): self.DEFAULT_LOCALE = DEFAULT_LOCALE
    def get_PARENT_REF(self): return self.PARENT_REF
    def set_PARENT_REF(self, PARENT_REF): self.PARENT_REF = PARENT_REF
    def get_EXT_REF(self): return self.EXT_REF
    def set_EXT_REF(self, EXT_REF): self.EXT_REF = EXT_REF
    def get_LANG_REF(self): return self.LANG_REF
    def set_LANG_REF(self, LANG_REF): self.LANG_REF = LANG_REF
    def hasContent_(self):
        if (
            self.ANNOTATION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tierType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tierType'):
        if self.TIER_ID is not None and 'TIER_ID' not in already_processed:
            already_processed.add('TIER_ID')
            outfile.write(' TIER_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TIER_ID), input_name='TIER_ID')), ))
        if self.PARTICIPANT is not None and 'PARTICIPANT' not in already_processed:
            already_processed.add('PARTICIPANT')
            outfile.write(' PARTICIPANT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PARTICIPANT), input_name='PARTICIPANT')), ))
        if self.ANNOTATOR is not None and 'ANNOTATOR' not in already_processed:
            already_processed.add('ANNOTATOR')
            outfile.write(' ANNOTATOR=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ANNOTATOR), input_name='ANNOTATOR')), ))
        if self.LINGUISTIC_TYPE_REF is not None and 'LINGUISTIC_TYPE_REF' not in already_processed:
            already_processed.add('LINGUISTIC_TYPE_REF')
            outfile.write(' LINGUISTIC_TYPE_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LINGUISTIC_TYPE_REF), input_name='LINGUISTIC_TYPE_REF')), ))
        if self.DEFAULT_LOCALE is not None and 'DEFAULT_LOCALE' not in already_processed:
            already_processed.add('DEFAULT_LOCALE')
            outfile.write(' DEFAULT_LOCALE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEFAULT_LOCALE), input_name='DEFAULT_LOCALE')), ))
        if self.PARENT_REF is not None and 'PARENT_REF' not in already_processed:
            already_processed.add('PARENT_REF')
            outfile.write(' PARENT_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PARENT_REF), input_name='PARENT_REF')), ))
        if self.EXT_REF is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            outfile.write(' EXT_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXT_REF), input_name='EXT_REF')), ))
        if self.LANG_REF is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            outfile.write(' LANG_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_REF), input_name='LANG_REF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANNOTATION_ in self.ANNOTATION:
            ANNOTATION_.export(outfile, level, namespace_, name_='ANNOTATION', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TIER_ID', node)
        if value is not None and 'TIER_ID' not in already_processed:
            already_processed.add('TIER_ID')
            self.TIER_ID = value
        value = find_attr_value_('PARTICIPANT', node)
        if value is not None and 'PARTICIPANT' not in already_processed:
            already_processed.add('PARTICIPANT')
            self.PARTICIPANT = value
        value = find_attr_value_('ANNOTATOR', node)
        if value is not None and 'ANNOTATOR' not in already_processed:
            already_processed.add('ANNOTATOR')
            self.ANNOTATOR = value
        value = find_attr_value_('LINGUISTIC_TYPE_REF', node)
        if value is not None and 'LINGUISTIC_TYPE_REF' not in already_processed:
            already_processed.add('LINGUISTIC_TYPE_REF')
            self.LINGUISTIC_TYPE_REF = value
        value = find_attr_value_('DEFAULT_LOCALE', node)
        if value is not None and 'DEFAULT_LOCALE' not in already_processed:
            already_processed.add('DEFAULT_LOCALE')
            self.DEFAULT_LOCALE = value
        value = find_attr_value_('PARENT_REF', node)
        if value is not None and 'PARENT_REF' not in already_processed:
            already_processed.add('PARENT_REF')
            self.PARENT_REF = value
        value = find_attr_value_('EXT_REF', node)
        if value is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            self.EXT_REF = value
        value = find_attr_value_('LANG_REF', node)
        if value is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            self.LANG_REF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ANNOTATION':
            obj_ = annotationType.factory()
            obj_.build(child_)
            self.ANNOTATION.append(obj_)
            obj_.original_tagname_ = 'ANNOTATION'
# end class tierType


class annotationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ALIGNABLE_ANNOTATION=None, REF_ANNOTATION=None):
        self.original_tagname_ = None
        self.ALIGNABLE_ANNOTATION = ALIGNABLE_ANNOTATION
        self.REF_ANNOTATION = REF_ANNOTATION
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotationType.subclass:
            return annotationType.subclass(*args_, **kwargs_)
        else:
            return annotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ALIGNABLE_ANNOTATION(self): return self.ALIGNABLE_ANNOTATION
    def set_ALIGNABLE_ANNOTATION(self, ALIGNABLE_ANNOTATION): self.ALIGNABLE_ANNOTATION = ALIGNABLE_ANNOTATION
    def get_REF_ANNOTATION(self): return self.REF_ANNOTATION
    def set_REF_ANNOTATION(self, REF_ANNOTATION): self.REF_ANNOTATION = REF_ANNOTATION
    def hasContent_(self):
        if (
            self.ALIGNABLE_ANNOTATION is not None or
            self.REF_ANNOTATION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='annotationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('annotationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='annotationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='annotationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='annotationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALIGNABLE_ANNOTATION is not None:
            self.ALIGNABLE_ANNOTATION.export(outfile, level, namespace_, name_='ALIGNABLE_ANNOTATION', pretty_print=pretty_print)
        if self.REF_ANNOTATION is not None:
            self.REF_ANNOTATION.export(outfile, level, namespace_, name_='REF_ANNOTATION', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ALIGNABLE_ANNOTATION':
            obj_ = alignableType.factory()
            obj_.build(child_)
            self.ALIGNABLE_ANNOTATION = obj_
            obj_.original_tagname_ = 'ALIGNABLE_ANNOTATION'
        elif nodeName_ == 'REF_ANNOTATION':
            obj_ = refAnnoType.factory()
            obj_.build(child_)
            self.REF_ANNOTATION = obj_
            obj_.original_tagname_ = 'REF_ANNOTATION'
# end class annotationType


class alignableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TIME_SLOT_REF1=None, TIME_SLOT_REF2=None, SVG_REF=None, ANNOTATION_ID=None, EXT_REF=None, LANG_REF=None, CVE_REF=None, ANNOTATION_VALUE=None):
        self.original_tagname_ = None
        self.TIME_SLOT_REF1 = _cast(None, TIME_SLOT_REF1)
        self.TIME_SLOT_REF2 = _cast(None, TIME_SLOT_REF2)
        self.SVG_REF = _cast(None, SVG_REF)
        self.ANNOTATION_ID = _cast(None, ANNOTATION_ID)
        self.EXT_REF = _cast(None, EXT_REF)
        self.LANG_REF = _cast(None, LANG_REF)
        self.CVE_REF = _cast(None, CVE_REF)
        self.ANNOTATION_VALUE = ANNOTATION_VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alignableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alignableType.subclass:
            return alignableType.subclass(*args_, **kwargs_)
        else:
            return alignableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ANNOTATION_VALUE(self): return self.ANNOTATION_VALUE
    def set_ANNOTATION_VALUE(self, ANNOTATION_VALUE): self.ANNOTATION_VALUE = ANNOTATION_VALUE
    def get_TIME_SLOT_REF1(self): return self.TIME_SLOT_REF1
    def set_TIME_SLOT_REF1(self, TIME_SLOT_REF1): self.TIME_SLOT_REF1 = TIME_SLOT_REF1
    def get_TIME_SLOT_REF2(self): return self.TIME_SLOT_REF2
    def set_TIME_SLOT_REF2(self, TIME_SLOT_REF2): self.TIME_SLOT_REF2 = TIME_SLOT_REF2
    def get_SVG_REF(self): return self.SVG_REF
    def set_SVG_REF(self, SVG_REF): self.SVG_REF = SVG_REF
    def get_ANNOTATION_ID(self): return self.ANNOTATION_ID
    def set_ANNOTATION_ID(self, ANNOTATION_ID): self.ANNOTATION_ID = ANNOTATION_ID
    def get_EXT_REF(self): return self.EXT_REF
    def set_EXT_REF(self, EXT_REF): self.EXT_REF = EXT_REF
    def get_LANG_REF(self): return self.LANG_REF
    def set_LANG_REF(self, LANG_REF): self.LANG_REF = LANG_REF
    def get_CVE_REF(self): return self.CVE_REF
    def set_CVE_REF(self, CVE_REF): self.CVE_REF = CVE_REF
    def hasContent_(self):
        if (
            self.ANNOTATION_VALUE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alignableType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alignableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alignableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alignableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alignableType'):
        if self.TIME_SLOT_REF1 is not None and 'TIME_SLOT_REF1' not in already_processed:
            already_processed.add('TIME_SLOT_REF1')
            outfile.write(' TIME_SLOT_REF1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TIME_SLOT_REF1), input_name='TIME_SLOT_REF1')), ))
        if self.TIME_SLOT_REF2 is not None and 'TIME_SLOT_REF2' not in already_processed:
            already_processed.add('TIME_SLOT_REF2')
            outfile.write(' TIME_SLOT_REF2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TIME_SLOT_REF2), input_name='TIME_SLOT_REF2')), ))
        if self.SVG_REF is not None and 'SVG_REF' not in already_processed:
            already_processed.add('SVG_REF')
            outfile.write(' SVG_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.SVG_REF), input_name='SVG_REF')), ))
        if self.ANNOTATION_ID is not None and 'ANNOTATION_ID' not in already_processed:
            already_processed.add('ANNOTATION_ID')
            outfile.write(' ANNOTATION_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ANNOTATION_ID), input_name='ANNOTATION_ID')), ))
        if self.EXT_REF is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            outfile.write(' EXT_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXT_REF), input_name='EXT_REF')), ))
        if self.LANG_REF is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            outfile.write(' LANG_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_REF), input_name='LANG_REF')), ))
        if self.CVE_REF is not None and 'CVE_REF' not in already_processed:
            already_processed.add('CVE_REF')
            outfile.write(' CVE_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CVE_REF), input_name='CVE_REF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='alignableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ANNOTATION_VALUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ANNOTATION_VALUE>%s</ANNOTATION_VALUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ANNOTATION_VALUE), input_name='ANNOTATION_VALUE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TIME_SLOT_REF1', node)
        if value is not None and 'TIME_SLOT_REF1' not in already_processed:
            already_processed.add('TIME_SLOT_REF1')
            self.TIME_SLOT_REF1 = value
        value = find_attr_value_('TIME_SLOT_REF2', node)
        if value is not None and 'TIME_SLOT_REF2' not in already_processed:
            already_processed.add('TIME_SLOT_REF2')
            self.TIME_SLOT_REF2 = value
        value = find_attr_value_('SVG_REF', node)
        if value is not None and 'SVG_REF' not in already_processed:
            already_processed.add('SVG_REF')
            self.SVG_REF = value
        value = find_attr_value_('ANNOTATION_ID', node)
        if value is not None and 'ANNOTATION_ID' not in already_processed:
            already_processed.add('ANNOTATION_ID')
            self.ANNOTATION_ID = value
        value = find_attr_value_('EXT_REF', node)
        if value is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            self.EXT_REF = value
        value = find_attr_value_('LANG_REF', node)
        if value is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            self.LANG_REF = value
        value = find_attr_value_('CVE_REF', node)
        if value is not None and 'CVE_REF' not in already_processed:
            already_processed.add('CVE_REF')
            self.CVE_REF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ANNOTATION_VALUE':
            ANNOTATION_VALUE_ = child_.text
            ANNOTATION_VALUE_ = self.gds_validate_string(ANNOTATION_VALUE_, node, 'ANNOTATION_VALUE')
            self.ANNOTATION_VALUE = ANNOTATION_VALUE_
# end class alignableType


class refAnnoType(GeneratedsSuper):
    """This is in fact a reference to the parent annotation."""
    subclass = None
    superclass = None
    def __init__(self, ANNOTATION_REF=None, PREVIOUS_ANNOTATION=None, ANNOTATION_ID=None, EXT_REF=None, LANG_REF=None, CVE_REF=None, ANNOTATION_VALUE=None):
        self.original_tagname_ = None
        self.ANNOTATION_REF = _cast(None, ANNOTATION_REF)
        self.PREVIOUS_ANNOTATION = _cast(None, PREVIOUS_ANNOTATION)
        self.ANNOTATION_ID = _cast(None, ANNOTATION_ID)
        self.EXT_REF = _cast(None, EXT_REF)
        self.LANG_REF = _cast(None, LANG_REF)
        self.CVE_REF = _cast(None, CVE_REF)
        self.ANNOTATION_VALUE = ANNOTATION_VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refAnnoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refAnnoType.subclass:
            return refAnnoType.subclass(*args_, **kwargs_)
        else:
            return refAnnoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ANNOTATION_VALUE(self): return self.ANNOTATION_VALUE
    def set_ANNOTATION_VALUE(self, ANNOTATION_VALUE): self.ANNOTATION_VALUE = ANNOTATION_VALUE
    def get_ANNOTATION_REF(self): return self.ANNOTATION_REF
    def set_ANNOTATION_REF(self, ANNOTATION_REF): self.ANNOTATION_REF = ANNOTATION_REF
    def get_PREVIOUS_ANNOTATION(self): return self.PREVIOUS_ANNOTATION
    def set_PREVIOUS_ANNOTATION(self, PREVIOUS_ANNOTATION): self.PREVIOUS_ANNOTATION = PREVIOUS_ANNOTATION
    def get_ANNOTATION_ID(self): return self.ANNOTATION_ID
    def set_ANNOTATION_ID(self, ANNOTATION_ID): self.ANNOTATION_ID = ANNOTATION_ID
    def get_EXT_REF(self): return self.EXT_REF
    def set_EXT_REF(self, EXT_REF): self.EXT_REF = EXT_REF
    def get_LANG_REF(self): return self.LANG_REF
    def set_LANG_REF(self, LANG_REF): self.LANG_REF = LANG_REF
    def get_CVE_REF(self): return self.CVE_REF
    def set_CVE_REF(self, CVE_REF): self.CVE_REF = CVE_REF
    def hasContent_(self):
        if (
            self.ANNOTATION_VALUE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='refAnnoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refAnnoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='refAnnoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='refAnnoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='refAnnoType'):
        if self.ANNOTATION_REF is not None and 'ANNOTATION_REF' not in already_processed:
            already_processed.add('ANNOTATION_REF')
            outfile.write(' ANNOTATION_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ANNOTATION_REF), input_name='ANNOTATION_REF')), ))
        if self.PREVIOUS_ANNOTATION is not None and 'PREVIOUS_ANNOTATION' not in already_processed:
            already_processed.add('PREVIOUS_ANNOTATION')
            outfile.write(' PREVIOUS_ANNOTATION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.PREVIOUS_ANNOTATION), input_name='PREVIOUS_ANNOTATION')), ))
        if self.ANNOTATION_ID is not None and 'ANNOTATION_ID' not in already_processed:
            already_processed.add('ANNOTATION_ID')
            outfile.write(' ANNOTATION_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ANNOTATION_ID), input_name='ANNOTATION_ID')), ))
        if self.EXT_REF is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            outfile.write(' EXT_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXT_REF), input_name='EXT_REF')), ))
        if self.LANG_REF is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            outfile.write(' LANG_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_REF), input_name='LANG_REF')), ))
        if self.CVE_REF is not None and 'CVE_REF' not in already_processed:
            already_processed.add('CVE_REF')
            outfile.write(' CVE_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CVE_REF), input_name='CVE_REF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='refAnnoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ANNOTATION_VALUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ANNOTATION_VALUE>%s</ANNOTATION_VALUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ANNOTATION_VALUE), input_name='ANNOTATION_VALUE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ANNOTATION_REF', node)
        if value is not None and 'ANNOTATION_REF' not in already_processed:
            already_processed.add('ANNOTATION_REF')
            self.ANNOTATION_REF = value
        value = find_attr_value_('PREVIOUS_ANNOTATION', node)
        if value is not None and 'PREVIOUS_ANNOTATION' not in already_processed:
            already_processed.add('PREVIOUS_ANNOTATION')
            self.PREVIOUS_ANNOTATION = value
        value = find_attr_value_('ANNOTATION_ID', node)
        if value is not None and 'ANNOTATION_ID' not in already_processed:
            already_processed.add('ANNOTATION_ID')
            self.ANNOTATION_ID = value
        value = find_attr_value_('EXT_REF', node)
        if value is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            self.EXT_REF = value
        value = find_attr_value_('LANG_REF', node)
        if value is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            self.LANG_REF = value
        value = find_attr_value_('CVE_REF', node)
        if value is not None and 'CVE_REF' not in already_processed:
            already_processed.add('CVE_REF')
            self.CVE_REF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ANNOTATION_VALUE':
            ANNOTATION_VALUE_ = child_.text
            ANNOTATION_VALUE_ = self.gds_validate_string(ANNOTATION_VALUE_, node, 'ANNOTATION_VALUE')
            self.ANNOTATION_VALUE = ANNOTATION_VALUE_
# end class refAnnoType


class lingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LINGUISTIC_TYPE_ID=None, TIME_ALIGNABLE=None, CONSTRAINTS=None, GRAPHIC_REFERENCES=None, CONTROLLED_VOCABULARY_REF=None, EXT_REF=None, LEXICON_REF=None):
        self.original_tagname_ = None
        self.LINGUISTIC_TYPE_ID = _cast(None, LINGUISTIC_TYPE_ID)
        self.TIME_ALIGNABLE = _cast(bool, TIME_ALIGNABLE)
        self.CONSTRAINTS = _cast(None, CONSTRAINTS)
        self.GRAPHIC_REFERENCES = _cast(bool, GRAPHIC_REFERENCES)
        self.CONTROLLED_VOCABULARY_REF = _cast(None, CONTROLLED_VOCABULARY_REF)
        self.EXT_REF = _cast(None, EXT_REF)
        self.LEXICON_REF = _cast(None, LEXICON_REF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lingType.subclass:
            return lingType.subclass(*args_, **kwargs_)
        else:
            return lingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LINGUISTIC_TYPE_ID(self): return self.LINGUISTIC_TYPE_ID
    def set_LINGUISTIC_TYPE_ID(self, LINGUISTIC_TYPE_ID): self.LINGUISTIC_TYPE_ID = LINGUISTIC_TYPE_ID
    def get_TIME_ALIGNABLE(self): return self.TIME_ALIGNABLE
    def set_TIME_ALIGNABLE(self, TIME_ALIGNABLE): self.TIME_ALIGNABLE = TIME_ALIGNABLE
    def get_CONSTRAINTS(self): return self.CONSTRAINTS
    def set_CONSTRAINTS(self, CONSTRAINTS): self.CONSTRAINTS = CONSTRAINTS
    def get_GRAPHIC_REFERENCES(self): return self.GRAPHIC_REFERENCES
    def set_GRAPHIC_REFERENCES(self, GRAPHIC_REFERENCES): self.GRAPHIC_REFERENCES = GRAPHIC_REFERENCES
    def get_CONTROLLED_VOCABULARY_REF(self): return self.CONTROLLED_VOCABULARY_REF
    def set_CONTROLLED_VOCABULARY_REF(self, CONTROLLED_VOCABULARY_REF): self.CONTROLLED_VOCABULARY_REF = CONTROLLED_VOCABULARY_REF
    def get_EXT_REF(self): return self.EXT_REF
    def set_EXT_REF(self, EXT_REF): self.EXT_REF = EXT_REF
    def get_LEXICON_REF(self): return self.LEXICON_REF
    def set_LEXICON_REF(self, LEXICON_REF): self.LEXICON_REF = LEXICON_REF
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lingType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lingType'):
        if self.LINGUISTIC_TYPE_ID is not None and 'LINGUISTIC_TYPE_ID' not in already_processed:
            already_processed.add('LINGUISTIC_TYPE_ID')
            outfile.write(' LINGUISTIC_TYPE_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LINGUISTIC_TYPE_ID), input_name='LINGUISTIC_TYPE_ID')), ))
        if self.TIME_ALIGNABLE is not None and 'TIME_ALIGNABLE' not in already_processed:
            already_processed.add('TIME_ALIGNABLE')
            outfile.write(' TIME_ALIGNABLE="%s"' % self.gds_format_boolean(self.TIME_ALIGNABLE, input_name='TIME_ALIGNABLE'))
        if self.CONSTRAINTS is not None and 'CONSTRAINTS' not in already_processed:
            already_processed.add('CONSTRAINTS')
            outfile.write(' CONSTRAINTS=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONSTRAINTS), input_name='CONSTRAINTS')), ))
        if self.GRAPHIC_REFERENCES is not None and 'GRAPHIC_REFERENCES' not in already_processed:
            already_processed.add('GRAPHIC_REFERENCES')
            outfile.write(' GRAPHIC_REFERENCES="%s"' % self.gds_format_boolean(self.GRAPHIC_REFERENCES, input_name='GRAPHIC_REFERENCES'))
        if self.CONTROLLED_VOCABULARY_REF is not None and 'CONTROLLED_VOCABULARY_REF' not in already_processed:
            already_processed.add('CONTROLLED_VOCABULARY_REF')
            outfile.write(' CONTROLLED_VOCABULARY_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CONTROLLED_VOCABULARY_REF), input_name='CONTROLLED_VOCABULARY_REF')), ))
        if self.EXT_REF is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            outfile.write(' EXT_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXT_REF), input_name='EXT_REF')), ))
        if self.LEXICON_REF is not None and 'LEXICON_REF' not in already_processed:
            already_processed.add('LEXICON_REF')
            outfile.write(' LEXICON_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LEXICON_REF), input_name='LEXICON_REF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='lingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LINGUISTIC_TYPE_ID', node)
        if value is not None and 'LINGUISTIC_TYPE_ID' not in already_processed:
            already_processed.add('LINGUISTIC_TYPE_ID')
            self.LINGUISTIC_TYPE_ID = value
        value = find_attr_value_('TIME_ALIGNABLE', node)
        if value is not None and 'TIME_ALIGNABLE' not in already_processed:
            already_processed.add('TIME_ALIGNABLE')
            if value in ('true', '1'):
                self.TIME_ALIGNABLE = True
            elif value in ('false', '0'):
                self.TIME_ALIGNABLE = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CONSTRAINTS', node)
        if value is not None and 'CONSTRAINTS' not in already_processed:
            already_processed.add('CONSTRAINTS')
            self.CONSTRAINTS = value
        value = find_attr_value_('GRAPHIC_REFERENCES', node)
        if value is not None and 'GRAPHIC_REFERENCES' not in already_processed:
            already_processed.add('GRAPHIC_REFERENCES')
            if value in ('true', '1'):
                self.GRAPHIC_REFERENCES = True
            elif value in ('false', '0'):
                self.GRAPHIC_REFERENCES = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('CONTROLLED_VOCABULARY_REF', node)
        if value is not None and 'CONTROLLED_VOCABULARY_REF' not in already_processed:
            already_processed.add('CONTROLLED_VOCABULARY_REF')
            self.CONTROLLED_VOCABULARY_REF = value
        value = find_attr_value_('EXT_REF', node)
        if value is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            self.EXT_REF = value
        value = find_attr_value_('LEXICON_REF', node)
        if value is not None and 'LEXICON_REF' not in already_processed:
            already_processed.add('LEXICON_REF')
            self.LEXICON_REF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class lingType


class localeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LANGUAGE_CODE=None, COUNTRY_CODE=None, VARIANT=None):
        self.original_tagname_ = None
        self.LANGUAGE_CODE = _cast(None, LANGUAGE_CODE)
        self.COUNTRY_CODE = _cast(None, COUNTRY_CODE)
        self.VARIANT = _cast(None, VARIANT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localeType.subclass:
            return localeType.subclass(*args_, **kwargs_)
        else:
            return localeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LANGUAGE_CODE(self): return self.LANGUAGE_CODE
    def set_LANGUAGE_CODE(self, LANGUAGE_CODE): self.LANGUAGE_CODE = LANGUAGE_CODE
    def get_COUNTRY_CODE(self): return self.COUNTRY_CODE
    def set_COUNTRY_CODE(self, COUNTRY_CODE): self.COUNTRY_CODE = COUNTRY_CODE
    def get_VARIANT(self): return self.VARIANT
    def set_VARIANT(self, VARIANT): self.VARIANT = VARIANT
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='localeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='localeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='localeType'):
        if self.LANGUAGE_CODE is not None and 'LANGUAGE_CODE' not in already_processed:
            already_processed.add('LANGUAGE_CODE')
            outfile.write(' LANGUAGE_CODE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANGUAGE_CODE), input_name='LANGUAGE_CODE')), ))
        if self.COUNTRY_CODE is not None and 'COUNTRY_CODE' not in already_processed:
            already_processed.add('COUNTRY_CODE')
            outfile.write(' COUNTRY_CODE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.COUNTRY_CODE), input_name='COUNTRY_CODE')), ))
        if self.VARIANT is not None and 'VARIANT' not in already_processed:
            already_processed.add('VARIANT')
            outfile.write(' VARIANT=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.VARIANT), input_name='VARIANT')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='localeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LANGUAGE_CODE', node)
        if value is not None and 'LANGUAGE_CODE' not in already_processed:
            already_processed.add('LANGUAGE_CODE')
            self.LANGUAGE_CODE = value
        value = find_attr_value_('COUNTRY_CODE', node)
        if value is not None and 'COUNTRY_CODE' not in already_processed:
            already_processed.add('COUNTRY_CODE')
            self.COUNTRY_CODE = value
        value = find_attr_value_('VARIANT', node)
        if value is not None and 'VARIANT' not in already_processed:
            already_processed.add('VARIANT')
            self.VARIANT = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class localeType


class constraintType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, STEREOTYPE=None, DESCRIPTION=None):
        self.original_tagname_ = None
        self.STEREOTYPE = _cast(None, STEREOTYPE)
        self.DESCRIPTION = _cast(None, DESCRIPTION)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintType.subclass:
            return constraintType.subclass(*args_, **kwargs_)
        else:
            return constraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STEREOTYPE(self): return self.STEREOTYPE
    def set_STEREOTYPE(self, STEREOTYPE): self.STEREOTYPE = STEREOTYPE
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='constraintType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='constraintType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='constraintType'):
        if self.STEREOTYPE is not None and 'STEREOTYPE' not in already_processed:
            already_processed.add('STEREOTYPE')
            outfile.write(' STEREOTYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.STEREOTYPE), input_name='STEREOTYPE')), ))
        if self.DESCRIPTION is not None and 'DESCRIPTION' not in already_processed:
            already_processed.add('DESCRIPTION')
            outfile.write(' DESCRIPTION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DESCRIPTION), input_name='DESCRIPTION')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='constraintType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('STEREOTYPE', node)
        if value is not None and 'STEREOTYPE' not in already_processed:
            already_processed.add('STEREOTYPE')
            self.STEREOTYPE = value
        value = find_attr_value_('DESCRIPTION', node)
        if value is not None and 'DESCRIPTION' not in already_processed:
            already_processed.add('DESCRIPTION')
            self.DESCRIPTION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class constraintType


class convocType(GeneratedsSuper):
    """A reference to an url of an external Controlled Vocabulary. Is
    intended to be mutually exclusive with a sequence of CV_ENTRY_ML
    elements."""
    subclass = None
    superclass = None
    def __init__(self, CV_ID=None, EXT_REF=None, DESCRIPTION=None, CV_ENTRY_ML=None):
        self.original_tagname_ = None
        self.CV_ID = _cast(None, CV_ID)
        self.EXT_REF = _cast(None, EXT_REF)
        if DESCRIPTION is None:
            self.DESCRIPTION = []
        else:
            self.DESCRIPTION = DESCRIPTION
        if CV_ENTRY_ML is None:
            self.CV_ENTRY_ML = []
        else:
            self.CV_ENTRY_ML = CV_ENTRY_ML
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, convocType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if convocType.subclass:
            return convocType.subclass(*args_, **kwargs_)
        else:
            return convocType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def add_DESCRIPTION(self, value): self.DESCRIPTION.append(value)
    def insert_DESCRIPTION_at(self, index, value): self.DESCRIPTION.insert(index, value)
    def replace_DESCRIPTION_at(self, index, value): self.DESCRIPTION[index] = value
    def get_CV_ENTRY_ML(self): return self.CV_ENTRY_ML
    def set_CV_ENTRY_ML(self, CV_ENTRY_ML): self.CV_ENTRY_ML = CV_ENTRY_ML
    def add_CV_ENTRY_ML(self, value): self.CV_ENTRY_ML.append(value)
    def insert_CV_ENTRY_ML_at(self, index, value): self.CV_ENTRY_ML.insert(index, value)
    def replace_CV_ENTRY_ML_at(self, index, value): self.CV_ENTRY_ML[index] = value
    def get_CV_ID(self): return self.CV_ID
    def set_CV_ID(self, CV_ID): self.CV_ID = CV_ID
    def get_EXT_REF(self): return self.EXT_REF
    def set_EXT_REF(self, EXT_REF): self.EXT_REF = EXT_REF
    def hasContent_(self):
        if (
            self.DESCRIPTION or
            self.CV_ENTRY_ML
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='convocType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('convocType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='convocType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='convocType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='convocType'):
        if self.CV_ID is not None and 'CV_ID' not in already_processed:
            already_processed.add('CV_ID')
            outfile.write(' CV_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CV_ID), input_name='CV_ID')), ))
        if self.EXT_REF is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            outfile.write(' EXT_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXT_REF), input_name='EXT_REF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='convocType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DESCRIPTION_ in self.DESCRIPTION:
            DESCRIPTION_.export(outfile, level, namespace_, name_='DESCRIPTION', pretty_print=pretty_print)
        for CV_ENTRY_ML_ in self.CV_ENTRY_ML:
            CV_ENTRY_ML_.export(outfile, level, namespace_, name_='CV_ENTRY_ML', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CV_ID', node)
        if value is not None and 'CV_ID' not in already_processed:
            already_processed.add('CV_ID')
            self.CV_ID = value
        value = find_attr_value_('EXT_REF', node)
        if value is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            self.EXT_REF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DESCRIPTION':
            obj_ = descMultiLangType.factory()
            obj_.build(child_)
            self.DESCRIPTION.append(obj_)
            obj_.original_tagname_ = 'DESCRIPTION'
        elif nodeName_ == 'CV_ENTRY_ML':
            obj_ = cventryType.factory()
            obj_.build(child_)
            self.CV_ENTRY_ML.append(obj_)
            obj_.original_tagname_ = 'CV_ENTRY_ML'
# end class convocType


class cventryType(GeneratedsSuper):
    """An entry in a multilingual controlled vocabulary, containing the
    values and the descriptions in multiple languages."""
    subclass = None
    superclass = None
    def __init__(self, CVE_ID=None, EXT_REF=None, CVE_VALUE=None):
        self.original_tagname_ = None
        self.CVE_ID = _cast(None, CVE_ID)
        self.EXT_REF = _cast(None, EXT_REF)
        if CVE_VALUE is None:
            self.CVE_VALUE = []
        else:
            self.CVE_VALUE = CVE_VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cventryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cventryType.subclass:
            return cventryType.subclass(*args_, **kwargs_)
        else:
            return cventryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CVE_VALUE(self): return self.CVE_VALUE
    def set_CVE_VALUE(self, CVE_VALUE): self.CVE_VALUE = CVE_VALUE
    def add_CVE_VALUE(self, value): self.CVE_VALUE.append(value)
    def insert_CVE_VALUE_at(self, index, value): self.CVE_VALUE.insert(index, value)
    def replace_CVE_VALUE_at(self, index, value): self.CVE_VALUE[index] = value
    def get_CVE_ID(self): return self.CVE_ID
    def set_CVE_ID(self, CVE_ID): self.CVE_ID = CVE_ID
    def get_EXT_REF(self): return self.EXT_REF
    def set_EXT_REF(self, EXT_REF): self.EXT_REF = EXT_REF
    def hasContent_(self):
        if (
            self.CVE_VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cventryType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cventryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cventryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cventryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cventryType'):
        if self.CVE_ID is not None and 'CVE_ID' not in already_processed:
            already_processed.add('CVE_ID')
            outfile.write(' CVE_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CVE_ID), input_name='CVE_ID')), ))
        if self.EXT_REF is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            outfile.write(' EXT_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXT_REF), input_name='EXT_REF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cventryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CVE_VALUE_ in self.CVE_VALUE:
            CVE_VALUE_.export(outfile, level, namespace_, name_='CVE_VALUE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CVE_ID', node)
        if value is not None and 'CVE_ID' not in already_processed:
            already_processed.add('CVE_ID')
            self.CVE_ID = value
        value = find_attr_value_('EXT_REF', node)
        if value is not None and 'EXT_REF' not in already_processed:
            already_processed.add('EXT_REF')
            self.EXT_REF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CVE_VALUE':
            obj_ = cveValueType.factory()
            obj_.build(child_)
            self.CVE_VALUE.append(obj_)
            obj_.original_tagname_ = 'CVE_VALUE'
# end class cventryType


class cveValueType(GeneratedsSuper):
    """A controlled vocabulary entry value with a language attribute. This
    allows multilingual controlled vocabularies. It adds a language
    reference attribute compared to the mono-lingual cv entry
    element."""
    subclass = None
    superclass = None
    def __init__(self, LANG_REF=None, DESCRIPTION=None, valueOf_=None):
        self.original_tagname_ = None
        self.LANG_REF = _cast(None, LANG_REF)
        self.DESCRIPTION = _cast(None, DESCRIPTION)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cveValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cveValueType.subclass:
            return cveValueType.subclass(*args_, **kwargs_)
        else:
            return cveValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LANG_REF(self): return self.LANG_REF
    def set_LANG_REF(self, LANG_REF): self.LANG_REF = LANG_REF
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cveValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cveValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cveValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cveValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cveValueType'):
        if self.LANG_REF is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            outfile.write(' LANG_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_REF), input_name='LANG_REF')), ))
        if self.DESCRIPTION is not None and 'DESCRIPTION' not in already_processed:
            already_processed.add('DESCRIPTION')
            outfile.write(' DESCRIPTION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DESCRIPTION), input_name='DESCRIPTION')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cveValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LANG_REF', node)
        if value is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            self.LANG_REF = value
        value = find_attr_value_('DESCRIPTION', node)
        if value is not None and 'DESCRIPTION' not in already_processed:
            already_processed.add('DESCRIPTION')
            self.DESCRIPTION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cveValueType


class descMultiLangType(GeneratedsSuper):
    """A description element with a language reference attribute."""
    subclass = None
    superclass = None
    def __init__(self, LANG_REF=None, valueOf_=None):
        self.original_tagname_ = None
        self.LANG_REF = _cast(None, LANG_REF)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descMultiLangType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descMultiLangType.subclass:
            return descMultiLangType.subclass(*args_, **kwargs_)
        else:
            return descMultiLangType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LANG_REF(self): return self.LANG_REF
    def set_LANG_REF(self, LANG_REF): self.LANG_REF = LANG_REF
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='descMultiLangType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descMultiLangType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='descMultiLangType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='descMultiLangType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='descMultiLangType'):
        if self.LANG_REF is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            outfile.write(' LANG_REF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_REF), input_name='LANG_REF')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='descMultiLangType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LANG_REF', node)
        if value is not None and 'LANG_REF' not in already_processed:
            already_processed.add('LANG_REF')
            self.LANG_REF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class descMultiLangType


class propType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NAME=None, valueOf_=None):
        self.original_tagname_ = None
        self.NAME = _cast(None, NAME)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propType.subclass:
            return propType.subclass(*args_, **kwargs_)
        else:
            return propType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('propType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propType'):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            outfile.write(' NAME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NAME), input_name='NAME')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propType


class extRefType(GeneratedsSuper):
    """A reference to the id of an ISO Data Category (url including id). A
    reference to an external (closed) Controlled Vocabulary (url). A
    reference to the id of an Entry in an external Controlled
    Vocabulary (id). A reference to the id of an entry in a lexicon
    (url, url+id or id) A reference or hyperlink to any type
    document (url)"""
    subclass = None
    superclass = None
    def __init__(self, EXT_REF_ID=None, TYPE=None, VALUE=None):
        self.original_tagname_ = None
        self.EXT_REF_ID = _cast(None, EXT_REF_ID)
        self.TYPE = _cast(None, TYPE)
        self.VALUE = _cast(None, VALUE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extRefType.subclass:
            return extRefType.subclass(*args_, **kwargs_)
        else:
            return extRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EXT_REF_ID(self): return self.EXT_REF_ID
    def set_EXT_REF_ID(self, EXT_REF_ID): self.EXT_REF_ID = EXT_REF_ID
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='extRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='extRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='extRefType'):
        if self.EXT_REF_ID is not None and 'EXT_REF_ID' not in already_processed:
            already_processed.add('EXT_REF_ID')
            outfile.write(' EXT_REF_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXT_REF_ID), input_name='EXT_REF_ID')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.VALUE is not None and 'VALUE' not in already_processed:
            already_processed.add('VALUE')
            outfile.write(' VALUE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.VALUE), input_name='VALUE')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='extRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EXT_REF_ID', node)
        if value is not None and 'EXT_REF_ID' not in already_processed:
            already_processed.add('EXT_REF_ID')
            self.EXT_REF_ID = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('VALUE', node)
        if value is not None and 'VALUE' not in already_processed:
            already_processed.add('VALUE')
            self.VALUE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class extRefType


class lexRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LEX_REF_ID=None, NAME=None, TYPE=None, URL=None, LEXICON_ID=None, LEXICON_NAME=None, DATCAT_ID=None, DATCAT_NAME=None):
        self.original_tagname_ = None
        self.LEX_REF_ID = _cast(None, LEX_REF_ID)
        self.NAME = _cast(None, NAME)
        self.TYPE = _cast(None, TYPE)
        self.URL = _cast(None, URL)
        self.LEXICON_ID = _cast(None, LEXICON_ID)
        self.LEXICON_NAME = _cast(None, LEXICON_NAME)
        self.DATCAT_ID = _cast(None, DATCAT_ID)
        self.DATCAT_NAME = _cast(None, DATCAT_NAME)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lexRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lexRefType.subclass:
            return lexRefType.subclass(*args_, **kwargs_)
        else:
            return lexRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LEX_REF_ID(self): return self.LEX_REF_ID
    def set_LEX_REF_ID(self, LEX_REF_ID): self.LEX_REF_ID = LEX_REF_ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_LEXICON_ID(self): return self.LEXICON_ID
    def set_LEXICON_ID(self, LEXICON_ID): self.LEXICON_ID = LEXICON_ID
    def get_LEXICON_NAME(self): return self.LEXICON_NAME
    def set_LEXICON_NAME(self, LEXICON_NAME): self.LEXICON_NAME = LEXICON_NAME
    def get_DATCAT_ID(self): return self.DATCAT_ID
    def set_DATCAT_ID(self, DATCAT_ID): self.DATCAT_ID = DATCAT_ID
    def get_DATCAT_NAME(self): return self.DATCAT_NAME
    def set_DATCAT_NAME(self, DATCAT_NAME): self.DATCAT_NAME = DATCAT_NAME
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lexRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lexRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lexRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lexRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lexRefType'):
        if self.LEX_REF_ID is not None and 'LEX_REF_ID' not in already_processed:
            already_processed.add('LEX_REF_ID')
            outfile.write(' LEX_REF_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LEX_REF_ID), input_name='LEX_REF_ID')), ))
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            outfile.write(' NAME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NAME), input_name='NAME')), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TYPE), input_name='TYPE')), ))
        if self.URL is not None and 'URL' not in already_processed:
            already_processed.add('URL')
            outfile.write(' URL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.URL), input_name='URL')), ))
        if self.LEXICON_ID is not None and 'LEXICON_ID' not in already_processed:
            already_processed.add('LEXICON_ID')
            outfile.write(' LEXICON_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LEXICON_ID), input_name='LEXICON_ID')), ))
        if self.LEXICON_NAME is not None and 'LEXICON_NAME' not in already_processed:
            already_processed.add('LEXICON_NAME')
            outfile.write(' LEXICON_NAME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LEXICON_NAME), input_name='LEXICON_NAME')), ))
        if self.DATCAT_ID is not None and 'DATCAT_ID' not in already_processed:
            already_processed.add('DATCAT_ID')
            outfile.write(' DATCAT_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DATCAT_ID), input_name='DATCAT_ID')), ))
        if self.DATCAT_NAME is not None and 'DATCAT_NAME' not in already_processed:
            already_processed.add('DATCAT_NAME')
            outfile.write(' DATCAT_NAME=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DATCAT_NAME), input_name='DATCAT_NAME')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='lexRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LEX_REF_ID', node)
        if value is not None and 'LEX_REF_ID' not in already_processed:
            already_processed.add('LEX_REF_ID')
            self.LEX_REF_ID = value
        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
        value = find_attr_value_('URL', node)
        if value is not None and 'URL' not in already_processed:
            already_processed.add('URL')
            self.URL = value
        value = find_attr_value_('LEXICON_ID', node)
        if value is not None and 'LEXICON_ID' not in already_processed:
            already_processed.add('LEXICON_ID')
            self.LEXICON_ID = value
        value = find_attr_value_('LEXICON_NAME', node)
        if value is not None and 'LEXICON_NAME' not in already_processed:
            already_processed.add('LEXICON_NAME')
            self.LEXICON_NAME = value
        value = find_attr_value_('DATCAT_ID', node)
        if value is not None and 'DATCAT_ID' not in already_processed:
            already_processed.add('DATCAT_ID')
            self.DATCAT_ID = value
        value = find_attr_value_('DATCAT_NAME', node)
        if value is not None and 'DATCAT_NAME' not in already_processed:
            already_processed.add('DATCAT_NAME')
            self.DATCAT_NAME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class lexRefType


class langType(GeneratedsSuper):
    """The Language element containing a reference to a language name or
    (if possible persistent) definition. ISO-639-3 still seems to be
    the best choice for language codes and closest to persistent
    language ID's seem to be the http://cdb.iso.org/lg/...
    identifiers also used by the iso-language-639-3 component in the
    CLARIN ComponentRegistry?"""
    subclass = None
    superclass = None
    def __init__(self, LANG_ID=None, LANG_DEF=None, LANG_LABEL=None):
        self.original_tagname_ = None
        self.LANG_ID = _cast(None, LANG_ID)
        self.LANG_DEF = _cast(None, LANG_DEF)
        self.LANG_LABEL = _cast(None, LANG_LABEL)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, langType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if langType.subclass:
            return langType.subclass(*args_, **kwargs_)
        else:
            return langType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LANG_ID(self): return self.LANG_ID
    def set_LANG_ID(self, LANG_ID): self.LANG_ID = LANG_ID
    def get_LANG_DEF(self): return self.LANG_DEF
    def set_LANG_DEF(self, LANG_DEF): self.LANG_DEF = LANG_DEF
    def get_LANG_LABEL(self): return self.LANG_LABEL
    def set_LANG_LABEL(self, LANG_LABEL): self.LANG_LABEL = LANG_LABEL
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='langType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('langType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='langType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='langType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='langType'):
        if self.LANG_ID is not None and 'LANG_ID' not in already_processed:
            already_processed.add('LANG_ID')
            outfile.write(' LANG_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_ID), input_name='LANG_ID')), ))
        if self.LANG_DEF is not None and 'LANG_DEF' not in already_processed:
            already_processed.add('LANG_DEF')
            outfile.write(' LANG_DEF=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_DEF), input_name='LANG_DEF')), ))
        if self.LANG_LABEL is not None and 'LANG_LABEL' not in already_processed:
            already_processed.add('LANG_LABEL')
            outfile.write(' LANG_LABEL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LANG_LABEL), input_name='LANG_LABEL')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='langType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LANG_ID', node)
        if value is not None and 'LANG_ID' not in already_processed:
            already_processed.add('LANG_ID')
            self.LANG_ID = value
        value = find_attr_value_('LANG_DEF', node)
        if value is not None and 'LANG_DEF' not in already_processed:
            already_processed.add('LANG_DEF')
            self.LANG_DEF = value
        value = find_attr_value_('LANG_LABEL', node)
        if value is not None and 'LANG_LABEL' not in already_processed:
            already_processed.add('LANG_LABEL')
            self.LANG_LABEL = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class langType


class licenseType(GeneratedsSuper):
    """The license element can be used to include license information in
    the eaf file itself."""
    subclass = None
    superclass = None
    def __init__(self, LICENSE_URL=None, valueOf_=None):
        self.original_tagname_ = None
        self.LICENSE_URL = _cast(None, LICENSE_URL)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, licenseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if licenseType.subclass:
            return licenseType.subclass(*args_, **kwargs_)
        else:
            return licenseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LICENSE_URL(self): return self.LICENSE_URL
    def set_LICENSE_URL(self, LICENSE_URL): self.LICENSE_URL = LICENSE_URL
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='licenseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('licenseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='licenseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='licenseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='licenseType'):
        if self.LICENSE_URL is not None and 'LICENSE_URL' not in already_processed:
            already_processed.add('LICENSE_URL')
            outfile.write(' LICENSE_URL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LICENSE_URL), input_name='LICENSE_URL')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='licenseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LICENSE_URL', node)
        if value is not None and 'LICENSE_URL' not in already_processed:
            already_processed.add('LICENSE_URL')
            self.LICENSE_URL = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class licenseType


class CV_RESOURCE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATE=None, AUTHOR=None, VERSION=None, LANGUAGE=None, CONTROLLED_VOCABULARY=None, EXTERNAL_REF=None):
        self.original_tagname_ = None
        if isinstance(DATE, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DATE, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DATE
        self.DATE = initvalue_
        self.AUTHOR = _cast(None, AUTHOR)
        self.VERSION = _cast(None, VERSION)
        if LANGUAGE is None:
            self.LANGUAGE = []
        else:
            self.LANGUAGE = LANGUAGE
        if CONTROLLED_VOCABULARY is None:
            self.CONTROLLED_VOCABULARY = []
        else:
            self.CONTROLLED_VOCABULARY = CONTROLLED_VOCABULARY
        if EXTERNAL_REF is None:
            self.EXTERNAL_REF = []
        else:
            self.EXTERNAL_REF = EXTERNAL_REF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CV_RESOURCE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CV_RESOURCE.subclass:
            return CV_RESOURCE.subclass(*args_, **kwargs_)
        else:
            return CV_RESOURCE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LANGUAGE(self): return self.LANGUAGE
    def set_LANGUAGE(self, LANGUAGE): self.LANGUAGE = LANGUAGE
    def add_LANGUAGE(self, value): self.LANGUAGE.append(value)
    def insert_LANGUAGE_at(self, index, value): self.LANGUAGE.insert(index, value)
    def replace_LANGUAGE_at(self, index, value): self.LANGUAGE[index] = value
    def get_CONTROLLED_VOCABULARY(self): return self.CONTROLLED_VOCABULARY
    def set_CONTROLLED_VOCABULARY(self, CONTROLLED_VOCABULARY): self.CONTROLLED_VOCABULARY = CONTROLLED_VOCABULARY
    def add_CONTROLLED_VOCABULARY(self, value): self.CONTROLLED_VOCABULARY.append(value)
    def insert_CONTROLLED_VOCABULARY_at(self, index, value): self.CONTROLLED_VOCABULARY.insert(index, value)
    def replace_CONTROLLED_VOCABULARY_at(self, index, value): self.CONTROLLED_VOCABULARY[index] = value
    def get_EXTERNAL_REF(self): return self.EXTERNAL_REF
    def set_EXTERNAL_REF(self, EXTERNAL_REF): self.EXTERNAL_REF = EXTERNAL_REF
    def add_EXTERNAL_REF(self, value): self.EXTERNAL_REF.append(value)
    def insert_EXTERNAL_REF_at(self, index, value): self.EXTERNAL_REF.insert(index, value)
    def replace_EXTERNAL_REF_at(self, index, value): self.EXTERNAL_REF[index] = value
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_AUTHOR(self): return self.AUTHOR
    def set_AUTHOR(self, AUTHOR): self.AUTHOR = AUTHOR
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def hasContent_(self):
        if (
            self.LANGUAGE or
            self.CONTROLLED_VOCABULARY or
            self.EXTERNAL_REF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CV_RESOURCE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CV_RESOURCE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CV_RESOURCE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CV_RESOURCE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CV_RESOURCE'):
        if self.DATE is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            outfile.write(' DATE="%s"' % self.gds_format_datetime(self.DATE, input_name='DATE'))
        if self.AUTHOR is not None and 'AUTHOR' not in already_processed:
            already_processed.add('AUTHOR')
            outfile.write(' AUTHOR=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.AUTHOR), input_name='AUTHOR')), ))
        if self.VERSION is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            outfile.write(' VERSION=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.VERSION), input_name='VERSION')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CV_RESOURCE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LANGUAGE_ in self.LANGUAGE:
            LANGUAGE_.export(outfile, level, namespace_, name_='LANGUAGE', pretty_print=pretty_print)
        for CONTROLLED_VOCABULARY_ in self.CONTROLLED_VOCABULARY:
            CONTROLLED_VOCABULARY_.export(outfile, level, namespace_, name_='CONTROLLED_VOCABULARY', pretty_print=pretty_print)
        for EXTERNAL_REF_ in self.EXTERNAL_REF:
            EXTERNAL_REF_.export(outfile, level, namespace_, name_='EXTERNAL_REF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DATE', node)
        if value is not None and 'DATE' not in already_processed:
            already_processed.add('DATE')
            try:
                self.DATE = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (DATE): %s' % exp)
        value = find_attr_value_('AUTHOR', node)
        if value is not None and 'AUTHOR' not in already_processed:
            already_processed.add('AUTHOR')
            self.AUTHOR = value
        value = find_attr_value_('VERSION', node)
        if value is not None and 'VERSION' not in already_processed:
            already_processed.add('VERSION')
            self.VERSION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LANGUAGE':
            obj_ = langType.factory()
            obj_.build(child_)
            self.LANGUAGE.append(obj_)
            obj_.original_tagname_ = 'LANGUAGE'
        elif nodeName_ == 'CONTROLLED_VOCABULARY':
            obj_ = convocType.factory()
            obj_.build(child_)
            self.CONTROLLED_VOCABULARY.append(obj_)
            obj_.original_tagname_ = 'CONTROLLED_VOCABULARY'
        elif nodeName_ == 'EXTERNAL_REF':
            obj_ = extRefType.factory()
            obj_.build(child_)
            self.EXTERNAL_REF.append(obj_)
            obj_.original_tagname_ = 'EXTERNAL_REF'
# end class CV_RESOURCE


class MEDIA_DESCRIPTORType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MEDIA_URL=None, RELATIVE_MEDIA_URL=None, MIME_TYPE=None, TIME_ORIGIN=None, EXTRACTED_FROM=None):
        self.original_tagname_ = None
        self.MEDIA_URL = _cast(None, MEDIA_URL)
        self.RELATIVE_MEDIA_URL = _cast(None, RELATIVE_MEDIA_URL)
        self.MIME_TYPE = _cast(None, MIME_TYPE)
        self.TIME_ORIGIN = _cast(int, TIME_ORIGIN)
        self.EXTRACTED_FROM = _cast(None, EXTRACTED_FROM)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MEDIA_DESCRIPTORType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MEDIA_DESCRIPTORType.subclass:
            return MEDIA_DESCRIPTORType.subclass(*args_, **kwargs_)
        else:
            return MEDIA_DESCRIPTORType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MEDIA_URL(self): return self.MEDIA_URL
    def set_MEDIA_URL(self, MEDIA_URL): self.MEDIA_URL = MEDIA_URL
    def get_RELATIVE_MEDIA_URL(self): return self.RELATIVE_MEDIA_URL
    def set_RELATIVE_MEDIA_URL(self, RELATIVE_MEDIA_URL): self.RELATIVE_MEDIA_URL = RELATIVE_MEDIA_URL
    def get_MIME_TYPE(self): return self.MIME_TYPE
    def set_MIME_TYPE(self, MIME_TYPE): self.MIME_TYPE = MIME_TYPE
    def get_TIME_ORIGIN(self): return self.TIME_ORIGIN
    def set_TIME_ORIGIN(self, TIME_ORIGIN): self.TIME_ORIGIN = TIME_ORIGIN
    def get_EXTRACTED_FROM(self): return self.EXTRACTED_FROM
    def set_EXTRACTED_FROM(self, EXTRACTED_FROM): self.EXTRACTED_FROM = EXTRACTED_FROM
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MEDIA_DESCRIPTORType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MEDIA_DESCRIPTORType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MEDIA_DESCRIPTORType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MEDIA_DESCRIPTORType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MEDIA_DESCRIPTORType'):
        if self.MEDIA_URL is not None and 'MEDIA_URL' not in already_processed:
            already_processed.add('MEDIA_URL')
            outfile.write(' MEDIA_URL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MEDIA_URL), input_name='MEDIA_URL')), ))
        if self.RELATIVE_MEDIA_URL is not None and 'RELATIVE_MEDIA_URL' not in already_processed:
            already_processed.add('RELATIVE_MEDIA_URL')
            outfile.write(' RELATIVE_MEDIA_URL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.RELATIVE_MEDIA_URL), input_name='RELATIVE_MEDIA_URL')), ))
        if self.MIME_TYPE is not None and 'MIME_TYPE' not in already_processed:
            already_processed.add('MIME_TYPE')
            outfile.write(' MIME_TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MIME_TYPE), input_name='MIME_TYPE')), ))
        if self.TIME_ORIGIN is not None and 'TIME_ORIGIN' not in already_processed:
            already_processed.add('TIME_ORIGIN')
            outfile.write(' TIME_ORIGIN="%s"' % self.gds_format_integer(self.TIME_ORIGIN, input_name='TIME_ORIGIN'))
        if self.EXTRACTED_FROM is not None and 'EXTRACTED_FROM' not in already_processed:
            already_processed.add('EXTRACTED_FROM')
            outfile.write(' EXTRACTED_FROM=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EXTRACTED_FROM), input_name='EXTRACTED_FROM')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MEDIA_DESCRIPTORType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MEDIA_URL', node)
        if value is not None and 'MEDIA_URL' not in already_processed:
            already_processed.add('MEDIA_URL')
            self.MEDIA_URL = value
        value = find_attr_value_('RELATIVE_MEDIA_URL', node)
        if value is not None and 'RELATIVE_MEDIA_URL' not in already_processed:
            already_processed.add('RELATIVE_MEDIA_URL')
            self.RELATIVE_MEDIA_URL = value
        value = find_attr_value_('MIME_TYPE', node)
        if value is not None and 'MIME_TYPE' not in already_processed:
            already_processed.add('MIME_TYPE')
            self.MIME_TYPE = value
        value = find_attr_value_('TIME_ORIGIN', node)
        if value is not None and 'TIME_ORIGIN' not in already_processed:
            already_processed.add('TIME_ORIGIN')
            try:
                self.TIME_ORIGIN = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('EXTRACTED_FROM', node)
        if value is not None and 'EXTRACTED_FROM' not in already_processed:
            already_processed.add('EXTRACTED_FROM')
            self.EXTRACTED_FROM = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MEDIA_DESCRIPTORType


class LINKED_FILE_DESCRIPTORType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LINK_URL=None, RELATIVE_LINK_URL=None, MIME_TYPE=None, TIME_ORIGIN=None, ASSOCIATED_WITH=None):
        self.original_tagname_ = None
        self.LINK_URL = _cast(None, LINK_URL)
        self.RELATIVE_LINK_URL = _cast(None, RELATIVE_LINK_URL)
        self.MIME_TYPE = _cast(None, MIME_TYPE)
        self.TIME_ORIGIN = _cast(int, TIME_ORIGIN)
        self.ASSOCIATED_WITH = _cast(None, ASSOCIATED_WITH)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LINKED_FILE_DESCRIPTORType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LINKED_FILE_DESCRIPTORType.subclass:
            return LINKED_FILE_DESCRIPTORType.subclass(*args_, **kwargs_)
        else:
            return LINKED_FILE_DESCRIPTORType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LINK_URL(self): return self.LINK_URL
    def set_LINK_URL(self, LINK_URL): self.LINK_URL = LINK_URL
    def get_RELATIVE_LINK_URL(self): return self.RELATIVE_LINK_URL
    def set_RELATIVE_LINK_URL(self, RELATIVE_LINK_URL): self.RELATIVE_LINK_URL = RELATIVE_LINK_URL
    def get_MIME_TYPE(self): return self.MIME_TYPE
    def set_MIME_TYPE(self, MIME_TYPE): self.MIME_TYPE = MIME_TYPE
    def get_TIME_ORIGIN(self): return self.TIME_ORIGIN
    def set_TIME_ORIGIN(self, TIME_ORIGIN): self.TIME_ORIGIN = TIME_ORIGIN
    def get_ASSOCIATED_WITH(self): return self.ASSOCIATED_WITH
    def set_ASSOCIATED_WITH(self, ASSOCIATED_WITH): self.ASSOCIATED_WITH = ASSOCIATED_WITH
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LINKED_FILE_DESCRIPTORType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LINKED_FILE_DESCRIPTORType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LINKED_FILE_DESCRIPTORType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LINKED_FILE_DESCRIPTORType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LINKED_FILE_DESCRIPTORType'):
        if self.LINK_URL is not None and 'LINK_URL' not in already_processed:
            already_processed.add('LINK_URL')
            outfile.write(' LINK_URL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LINK_URL), input_name='LINK_URL')), ))
        if self.RELATIVE_LINK_URL is not None and 'RELATIVE_LINK_URL' not in already_processed:
            already_processed.add('RELATIVE_LINK_URL')
            outfile.write(' RELATIVE_LINK_URL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.RELATIVE_LINK_URL), input_name='RELATIVE_LINK_URL')), ))
        if self.MIME_TYPE is not None and 'MIME_TYPE' not in already_processed:
            already_processed.add('MIME_TYPE')
            outfile.write(' MIME_TYPE=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MIME_TYPE), input_name='MIME_TYPE')), ))
        if self.TIME_ORIGIN is not None and 'TIME_ORIGIN' not in already_processed:
            already_processed.add('TIME_ORIGIN')
            outfile.write(' TIME_ORIGIN="%s"' % self.gds_format_integer(self.TIME_ORIGIN, input_name='TIME_ORIGIN'))
        if self.ASSOCIATED_WITH is not None and 'ASSOCIATED_WITH' not in already_processed:
            already_processed.add('ASSOCIATED_WITH')
            outfile.write(' ASSOCIATED_WITH=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ASSOCIATED_WITH), input_name='ASSOCIATED_WITH')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LINKED_FILE_DESCRIPTORType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LINK_URL', node)
        if value is not None and 'LINK_URL' not in already_processed:
            already_processed.add('LINK_URL')
            self.LINK_URL = value
        value = find_attr_value_('RELATIVE_LINK_URL', node)
        if value is not None and 'RELATIVE_LINK_URL' not in already_processed:
            already_processed.add('RELATIVE_LINK_URL')
            self.RELATIVE_LINK_URL = value
        value = find_attr_value_('MIME_TYPE', node)
        if value is not None and 'MIME_TYPE' not in already_processed:
            already_processed.add('MIME_TYPE')
            self.MIME_TYPE = value
        value = find_attr_value_('TIME_ORIGIN', node)
        if value is not None and 'TIME_ORIGIN' not in already_processed:
            already_processed.add('TIME_ORIGIN')
            try:
                self.TIME_ORIGIN = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ASSOCIATED_WITH', node)
        if value is not None and 'ASSOCIATED_WITH' not in already_processed:
            already_processed.add('ASSOCIATED_WITH')
            self.ASSOCIATED_WITH = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LINKED_FILE_DESCRIPTORType


class TIME_SLOTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TIME_SLOT_ID=None, TIME_VALUE=None):
        self.original_tagname_ = None
        self.TIME_SLOT_ID = _cast(None, TIME_SLOT_ID)
        self.TIME_VALUE = _cast(int, TIME_VALUE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIME_SLOTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIME_SLOTType.subclass:
            return TIME_SLOTType.subclass(*args_, **kwargs_)
        else:
            return TIME_SLOTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TIME_SLOT_ID(self): return self.TIME_SLOT_ID
    def set_TIME_SLOT_ID(self, TIME_SLOT_ID): self.TIME_SLOT_ID = TIME_SLOT_ID
    def get_TIME_VALUE(self): return self.TIME_VALUE
    def set_TIME_VALUE(self, TIME_VALUE): self.TIME_VALUE = TIME_VALUE
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TIME_SLOTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIME_SLOTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TIME_SLOTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TIME_SLOTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TIME_SLOTType'):
        if self.TIME_SLOT_ID is not None and 'TIME_SLOT_ID' not in already_processed:
            already_processed.add('TIME_SLOT_ID')
            outfile.write(' TIME_SLOT_ID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TIME_SLOT_ID), input_name='TIME_SLOT_ID')), ))
        if self.TIME_VALUE is not None and 'TIME_VALUE' not in already_processed:
            already_processed.add('TIME_VALUE')
            outfile.write(' TIME_VALUE="%s"' % self.gds_format_integer(self.TIME_VALUE, input_name='TIME_VALUE'))
    def exportChildren(self, outfile, level, namespace_='', name_='TIME_SLOTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TIME_SLOT_ID', node)
        if value is not None and 'TIME_SLOT_ID' not in already_processed:
            already_processed.add('TIME_SLOT_ID')
            self.TIME_SLOT_ID = value
        value = find_attr_value_('TIME_VALUE', node)
        if value is not None and 'TIME_VALUE' not in already_processed:
            already_processed.add('TIME_VALUE')
            try:
                self.TIME_VALUE = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TIME_SLOTType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ANNOTATION_DOCUMENT'
        rootClass = ANNOTATION_DOCUMENT
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ANNOTATION_DOCUMENT'
        rootClass = ANNOTATION_DOCUMENT
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ANNOTATION_DOCUMENT'
        rootClass = ANNOTATION_DOCUMENT
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ANNOTATION_DOCUMENT'
        rootClass = ANNOTATION_DOCUMENT
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from EAF import *\n\n')
        sys.stdout.write('import EAF as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ANNOTATION_DOCUMENT",
    "CV_RESOURCE",
    "LINKED_FILE_DESCRIPTORType",
    "MEDIA_DESCRIPTORType",
    "TIME_SLOTType",
    "alignableType",
    "annotationType",
    "constraintType",
    "convocType",
    "cveValueType",
    "cventryType",
    "descMultiLangType",
    "extRefType",
    "headType",
    "langType",
    "lexRefType",
    "licenseType",
    "lingType",
    "localeType",
    "propType",
    "refAnnoType",
    "tierType",
    "timeType"
]
